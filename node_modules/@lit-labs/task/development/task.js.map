{"version":3,"file":"task.js","sourceRoot":"","sources":["../src/task.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport {notEqual} from '@lit/reactive-element';\nimport {ReactiveControllerHost} from '@lit/reactive-element/reactive-controller.js';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type TaskFunction<D extends ReadonlyArray<unknown>, R = any> = (\n  args: D\n) => R | typeof initialState | Promise<R | typeof initialState>;\nexport type ArgsFunction<D extends ReadonlyArray<unknown>> = () => D;\n\n// `DepsFunction` is being maintained for BC with its previous name.\nexport {ArgsFunction as DepsFunction};\n\n/**\n * States for task status\n */\nexport const TaskStatus = {\n  INITIAL: 0,\n  PENDING: 1,\n  COMPLETE: 2,\n  ERROR: 3,\n} as const;\n\n/**\n * A special value that can be returned from task functions to reset the task\n * status to INITIAL.\n */\nexport const initialState = Symbol();\n\nexport type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus];\n\nexport type StatusRenderer<R> = {\n  initial?: () => unknown;\n  pending?: () => unknown;\n  complete?: (value: R) => unknown;\n  error?: (error: unknown) => unknown;\n};\n\nexport interface TaskConfig<T extends ReadonlyArray<unknown>, R> {\n  task: TaskFunction<T, R>;\n  args?: ArgsFunction<T>;\n  autoRun?: boolean;\n  onComplete?: (value: R) => unknown;\n  onError?: (error: unknown) => unknown;\n}\n\n// TODO(sorvell): Some issues:\n// 1. When task is triggered in `updated`, this generates a ReactiveElement\n// warning that the update was triggered in response to an update.\n// 2. And as a result of triggering in `updated`, if the user waits for the\n// `updateComplete` promise they will not see a `pending` state since this\n// will be triggered in another update; they would need to\n// `while (!(await el.updateComplete));`.\n// 3. If this is instead or additionally triggered in `willUpdate`, the\n// warning goes away in the common case that the update itself does not change\n// the deps; however, the `requestUpdate` to render pending state  will not\n// trigger another update since the element is updating. This `requestUpdate`\n// could be triggered in updated, but that results in the same issue as #2.\n// 4. There is no good signal for when the task has resolved and rendered other\n// than requestAnimationFrame. The user would need to store a promise for the\n// task and then wait for that and the element to update.\n\n/**\n * A controller that performs an asynchronous task like a fetch when its host\n * element updates. The controller performs an update on the host element\n * when the task becomes pending and when it completes. The task function must\n * be supplied and can take a list of dependencies specified as a function that\n * returns a list of values. The `value` property reports the completed value,\n * and the `error` property an error state if one occurs. The `status` property\n * can be checked for status and is of type `TaskStatus` which has states for\n * initial, pending, complete, and error. The `render` method accepts an\n * object with optional corresponding state method to easily render values\n * corresponding to the task state.\n *\n * The task is run automatically when its arguments change; however, this can\n * be customized by setting `autoRun` to false and calling `run` explicitly\n * to run the task.\n *\n * class MyElement extends ReactiveElement {\n *   url = 'example.com/api';\n *   id = 0;\n *   task = new Task(\n *     this, {\n *       task: ([url, id]) =>\n *         fetch(`${this.url}?id=${this.id}`).then(response => response.json()),\n *       args: () => [this.id, this.url]\n *     }\n *   );\n *\n *   update(changedProperties) {\n *     super.update(changedProperties);\n *     this.task.render({\n *       pending: () => console.log('task pending'),\n *       complete: (value) => console.log('task value', value);\n *     });\n *   }\n * }\n */\nexport class Task<\n  T extends ReadonlyArray<unknown> = ReadonlyArray<unknown>,\n  R = unknown\n> {\n  private _previousArgs?: T;\n  private _task: TaskFunction<T, R>;\n  private _getArgs?: ArgsFunction<T>;\n  private _callId = 0;\n  private _host: ReactiveControllerHost;\n  private _value?: R;\n  private _error?: unknown;\n  private _onComplete?: (result: R) => unknown;\n  private _onError?: (error: unknown) => unknown;\n  status: TaskStatus = TaskStatus.INITIAL;\n\n  /**\n   * Controls if they task will run when its arguments change. Defaults to true.\n   */\n  autoRun = true;\n\n  /**\n   * A Promise that resolve when the current task run is complete.\n   *\n   * If a new task run is started while a previous run is pending, the Promise\n   * is kept and only resolved when the new run is completed.\n   */\n  get taskComplete(): Promise<R> {\n    // If a task run exists, return the cached promise. This is true in the case\n    // where the user has called taskComplete in pending or completed state\n    // before and has not started a new task run since.\n    if (this._taskComplete) {\n      return this._taskComplete;\n    }\n\n    // Generate an in-progress promise if the the status is pending and has been\n    // cleared by .run().\n    if (this.status === TaskStatus.PENDING) {\n      this._taskComplete = new Promise((res, rej) => {\n        this._resolveTaskComplete = res;\n        this._rejectTaskComplete = rej;\n      });\n      // If the status is error, return a rejected promise.\n    } else if (this.status === TaskStatus.ERROR) {\n      this._taskComplete = Promise.reject(this._error);\n      // Otherwise we are at a task run's completion or this is the first\n      // request and we are not in the middle of a task (i.e. INITIAL).\n    } else {\n      this._taskComplete = Promise.resolve(this._value!);\n    }\n\n    return this._taskComplete;\n  }\n\n  private _resolveTaskComplete?: (value: R) => void;\n  private _rejectTaskComplete?: (e: unknown) => void;\n  private _taskComplete?: Promise<R>;\n\n  constructor(\n    host: ReactiveControllerHost,\n    task: TaskFunction<T, R>,\n    args?: ArgsFunction<T>\n  );\n  constructor(host: ReactiveControllerHost, task: TaskConfig<T, R>);\n  constructor(\n    host: ReactiveControllerHost,\n    task: TaskFunction<T, R> | TaskConfig<T, R>,\n    args?: ArgsFunction<T>\n  ) {\n    this._host = host;\n    this._host.addController(this);\n    const taskConfig =\n      typeof task === 'object' ? task : ({task, args} as TaskConfig<T, R>);\n    this._task = taskConfig.task;\n    this._getArgs = taskConfig.args;\n    this._onComplete = taskConfig.onComplete;\n    this._onError = taskConfig.onError;\n    if (taskConfig.autoRun !== undefined) {\n      this.autoRun = taskConfig.autoRun;\n    }\n  }\n\n  hostUpdated() {\n    this.performTask();\n  }\n\n  protected async performTask() {\n    const args = this._getArgs?.();\n    if (this.shouldRun(args)) {\n      await this.run(args);\n    }\n  }\n\n  /**\n   * Determines if the task should run when it's triggered as part of the\n   * host's reactive lifecycle. Note, this is not checked when `run` is\n   * explicitly called. A task runs automatically when `autoRun` is `true` and\n   * either its arguments change.\n   * @param args The task's arguments\n   * @returns\n   */\n  protected shouldRun(args?: T) {\n    return this.autoRun && this._argsDirty(args);\n  }\n\n  /**\n   * A task runs when its arguments change, as long as the `autoRun` option\n   * has not been set to false. To explicitly run a task outside of these\n   * conditions, call `run`. A custom set of arguments can optionally be passed\n   * and if not given, the configured arguments are used.\n   * @param args optional set of arguments to use for this task run\n   */\n  async run(args?: T) {\n    args ??= this._getArgs?.();\n\n    // Clear the last complete task run in INITIAL because it may be a resolved\n    // promise. Also clear if COMPLETE or ERROR because the value returned by\n    // awaiting taskComplete may have changed since last run.\n    if (this.status !== TaskStatus.PENDING) {\n      this._taskComplete = undefined;\n      this._resolveTaskComplete = undefined;\n      this._rejectTaskComplete = undefined;\n    }\n\n    this.status = TaskStatus.PENDING;\n    let result!: R | typeof initialState;\n    let error: unknown;\n\n    // Request an update to report pending state. Do this in a\n    // microtask to avoid the change-in-update warning\n    queueMicrotask(() => this._host.requestUpdate());\n\n    const key = ++this._callId;\n    try {\n      result = await this._task(args!);\n    } catch (e) {\n      error = e;\n    }\n    // If this is the most recent task call, process this value.\n    if (this._callId === key) {\n      if (result === initialState) {\n        this.status = TaskStatus.INITIAL;\n      } else {\n        if (error === undefined) {\n          try {\n            this._onComplete?.(result as R);\n          } catch {\n            // Ignore user errors from onComplete.\n          }\n          this.status = TaskStatus.COMPLETE;\n          this._resolveTaskComplete?.(result as R);\n        } else {\n          try {\n            this._onError?.(error);\n          } catch {\n            // Ignore user errors from onError.\n          }\n          this.status = TaskStatus.ERROR;\n          this._rejectTaskComplete?.(error);\n        }\n        this._value = result as R;\n        this._error = error;\n      }\n      // Request an update with the final value.\n      this._host.requestUpdate();\n    }\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  get error() {\n    return this._error;\n  }\n\n  render(renderer: StatusRenderer<R>) {\n    switch (this.status) {\n      case TaskStatus.INITIAL:\n        return renderer.initial?.();\n      case TaskStatus.PENDING:\n        return renderer.pending?.();\n      case TaskStatus.COMPLETE:\n        return renderer.complete?.(this.value!);\n      case TaskStatus.ERROR:\n        return renderer.error?.(this.error);\n      default:\n        // exhaustiveness check\n        this.status as void;\n    }\n  }\n\n  private _argsDirty(args?: T) {\n    const prev = this._previousArgs;\n    this._previousArgs = args;\n    return Array.isArray(args) && Array.isArray(prev)\n      ? args.length === prev.length && args.some((v, i) => notEqual(v, prev[i]))\n      : args !== prev;\n  }\n}\n"]}